package com.hmellema.sgf4j.api;

import com.hmellema.sgf4j.extension.CodeGenExtension;
import com.hmellema.sgf4j.gendata.ShapeGenMetadata;
import com.hmellema.sgf4j.mapping.ShapeGenLoader;
import com.hmellema.sgf4j.mapping.ShapeGenMetadataMap;
import com.hmellema.sgf4j.util.ExtensionLoader;
import com.squareup.javapoet.JavaFile;
import org.pf4j.JarPluginManager;
import org.pf4j.PluginManager;

import java.util.List;
import java.util.Optional;

public interface Sgf4jGenerator {
    /** Generates java files from a model
     *
     * @param request generation request
     * @return List of generated files
     */
    static List<JavaFile> generate(Sgf4jGenerationRequest request) {
        var shapeGenLoader = new ShapeGenLoader(request.model());
        var extensions = ExtensionLoader.load();

        for (var extension : extensions) {
            if (nonNullOrEmpty(extension.getResolvers())) {
                shapeGenLoader.registerAllResolvers(extension.getResolvers());
            }
            if (nonNullOrEmpty(extension.getProcessors())) {
                shapeGenLoader.registerAllProcessors(extension.getProcessors());
            }
        }

        var shapeGenMap = shapeGenLoader.resolve();

        return generate(shapeGenMap);
    }

    static boolean nonNullOrEmpty(List<?> list) {
        return list != null && !list.isEmpty();
    }


    /** Generates java files from a resolved shapeGenMetadataMap
     *
     * @param shapeGenMetadataMap resolved and processed map of metadata needed to generate shape
     * @return List of java files generated by shape metadata map
     */
    static List<JavaFile> generate(ShapeGenMetadataMap shapeGenMetadataMap) {
        return shapeGenMetadataMap.values().stream()
                .map(shapeGenMetadata -> Sgf4jGenerator.generate(shapeGenMetadata, shapeGenMetadataMap))
                .filter(Optional::isPresent)
                .map(Optional::get)
                .toList();
    }

    /** Generate the JavaPoet {@link JavaFile} for a shape
     *
     * @param shapeGenMetadata input shape metadata
     * @return Optional of the generated {@link JavaFile}. If the shape does not represent a standalone java class this should return Optional.empty
     */
    static Optional<JavaFile> generate(ShapeGenMetadata shapeGenMetadata, ShapeGenMetadataMap shapeGenMetadataMap) {
        var typeOptional = shapeGenMetadata.asClass(shapeGenMetadataMap);

        if (typeOptional.isPresent()) {
            final JavaFile.Builder fileBuilder = JavaFile.builder(shapeGenMetadata.getNameSpace(), typeOptional.get());

            // Add any Tests for the overall class
            shapeGenMetadata.getFileTest().ifPresent(fileBuilder::addFileComment);

            // Add any static imports to the top of the file
            if (!shapeGenMetadata.getStaticImports().isEmpty()) {
                for (var staticImportEntry : shapeGenMetadata.getStaticImports().entrySet()) {
                    fileBuilder.addStaticImport(staticImportEntry.getKey(), staticImportEntry.getValue());
                }
            }

            return Optional.of(fileBuilder.build());
        }

        return Optional.empty();
    }
}
